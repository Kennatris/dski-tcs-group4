<!DOCTYPE html>
<html lang="en"> <head>
    <meta charset="UTF-8">
    <title>Sorting Visualization</title> <link rel="stylesheet" href="visualizer.css" />
</head>
<body>
<canvas id="canvas" width="600" height="298"></canvas>
<p id="status">Status: Connecting...</p>

<script>
    // --- Canvas and Context ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusElement = document.getElementById('status');

    // --- Get URL Parameters ---
    const params = new URLSearchParams(window.location.search);
    const algorithm = params.get('algo'); // Algorithm name
    const dataset = params.get('dataset'); // Dataset name (optional)
    const speed = params.get('speed');     // Visualization speed (delay in ms)
    const count = params.get('count');     // Element count (used if dataset is generated)

    // --- Build Backend SSE URL ---
    let url = `/api/compare/visualizer/${algorithm}`; // Base URL
    const queryParams = [];
    // Add optional parameters if they exist
    if (dataset) queryParams.push(`dataset=${encodeURIComponent(dataset)}`);
    if (speed) queryParams.push(`speed=${speed}`);
    if (count) queryParams.push(`count=${encodeURIComponent(count)}`);
    // Append query string if parameters were added
    if (queryParams.length > 0) url += `?${queryParams.join('&')}`;

    // --- State Variables ---
    let startTime = null; // Timestamp when connection opened
    let timerId = null; // Interval ID for updating elapsed time display
    let lastReceivedData = null; // Raw JSON string of the last received step
    let lastProcessedArrayState = null; // Stringified array state of the last drawn step (optional optimization)
    let isFinished = false; // Flag indicating if the sorting/SSE stream has finished

    // --- Highlight History (for fading effect) ---
    // Store the indices from the most recent N steps
    let recentlyChangedIndices = []; // Stores last N changed indices (drawn red)
    let recentlyAccessedIndices = []; // Stores last N accessed indices (drawn yellow)
    const HIGHLIGHT_COUNT = 6; // How many steps back to keep highlights visible

    // --- Color Constants ---
    const COLOR_FINISHED = '#28a745'; // Green for final sorted state
    const COLOR_CHANGED = '#dc3545';  // Red for recently changed elements
    const COLOR_ACCESSED = '#ffc107'; // Yellow for recently accessed elements
    const COLOR_DEFAULT = 'steelblue'; // Default bar color

    /**
     * Updates the elapsed time display in the status element.
     */
    function updateElapsedTime() {
        if (!startTime || isFinished) return; // Only update if running
        const now = Date.now();
        const elapsedSeconds = ((now - startTime) / 1000).toFixed(1); // Calculate seconds elapsed
        statusElement.textContent = `Status: Running... Elapsed: ${elapsedSeconds}s`;
    }

    /**
     * Updates a highlight list (accessed or changed) by adding new indices
     * and ensuring the list doesn't exceed HIGHLIGHT_COUNT.
     * New indices are added to the end, oldest ones are removed from the start.
     * @param {number[]} indexList - The highlight list to update (e.g., recentlyChangedIndices).
     * @param {number[]} newIndices - The indices from the current SortStep.
     */
    function updateHighlightList(indexList, newIndices) {
        newIndices.forEach(index => {
            // Remove the index if it already exists to move it to the end (most recent)
            const existingPos = indexList.indexOf(index);
            if (existingPos > -1) {
                indexList.splice(existingPos, 1);
            }
            // Add the new index to the end
            indexList.push(index);
        });
        // Remove oldest indices from the beginning if the list exceeds the limit
        while (indexList.length > HIGHLIGHT_COUNT) {
            indexList.shift();
        }
    }

    // --- EventSource Setup ---
    statusElement.textContent = 'Status: Connecting...'; // Initial status
    const evtSource = new EventSource(url); // Create the EventSource connection

    /**
     * Handles the 'open' event of the EventSource connection.
     * Initializes timer and resets state variables.
     */
    evtSource.onopen = function() {
        startTime = Date.now(); // Record start time
        statusElement.textContent = 'Status: Running... Elapsed: 0.0s'; // Update status
        timerId = setInterval(updateElapsedTime, 100); // Start updating elapsed time
        // Reset state for potential reconnection
        lastReceivedData = null;
        lastProcessedArrayState = null;
        isFinished = false;
        recentlyChangedIndices = [];
        recentlyAccessedIndices = [];
    };

    /**
     * Handles incoming 'message' events from the EventSource (SSE stream).
     * Parses the SortStep data and triggers a redraw of the canvas.
     */
    evtSource.onmessage = function(event) {
        if (isFinished) return; // Ignore messages after completion/error

        // Optimization: Avoid parsing and drawing if the raw data hasn't changed
        if (event.data === lastReceivedData) return;
        lastReceivedData = event.data;

        try {
            // Parse the JSON data received from the server
            const stepData = JSON.parse(event.data);
            const currentArray = stepData.currentArray;
            // Get accessed/changed indices, defaulting to empty arrays if missing
            const currentAccessed = stepData.accessedIndices || [];
            const currentChanged = stepData.changedIndices || [];

            // Basic validation: ensure we have an array to draw
            if (!currentArray) {
                console.warn("Received step data missing 'currentArray':", stepData);
                return;
            }

            // Optional Optimization: Prevent redraw if only highlights changed, not the array itself
            // const currentArrayString = JSON.stringify(currentArray);
            // if (currentArrayString === lastProcessedArrayState) return;
            // lastProcessedArrayState = currentArrayString;

            // --- Update Highlight History ---
            updateHighlightList(recentlyChangedIndices, currentChanged);
            updateHighlightList(recentlyAccessedIndices, currentAccessed);

            // --- Redraw Canvas ---
            // Draw using the current array state and the updated recent highlights
            drawArray(currentArray, new Set(recentlyAccessedIndices), new Set(recentlyChangedIndices), false);

        } catch (error) {
            // Handle JSON parsing errors
            console.error("Failed to parse SSE data:", error, event.data);
            statusElement.textContent = 'Status: Error parsing data!';
            if (timerId) clearInterval(timerId); // Stop timer
            isFinished = true; // Mark as finished
            evtSource.close(); // Close connection
        }
    };

    /**
     * Handles 'error' events or the closing of the EventSource connection.
     * Updates status and draws the final state if available.
     */
    evtSource.onerror = function(event) {
        isFinished = true; // Mark as finished
        if (timerId) clearInterval(timerId); // Stop timer

        // Check if the connection closed normally or if it was an actual error
        if (evtSource.readyState === EventSource.CLOSED || event.eventPhase === EventSource.CLOSED) {
            // Connection closed successfully (end of stream)
            if (startTime) {
                // Calculate final elapsed time
                const finalElapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
                statusElement.textContent = `Status: Finished in ${finalElapsedSeconds}s`;
            } else {
                statusElement.textContent = 'Status: Finished (connection closed)';
            }

            // Draw the very last received state in green (finished state)
            if(lastReceivedData) {
                try {
                    const stepData = JSON.parse(lastReceivedData);
                    const finalArray = stepData.currentArray;
                    if (finalArray) {
                        // Draw final state without any red/yellow highlights
                        drawArray(finalArray, new Set(), new Set(), true); // isFinishedState = true
                    }
                } catch(e){
                    console.error("Error drawing final state:", e);
                }
            }
        } else {
            // An actual error occurred
            statusElement.textContent = 'Status: Error or disconnected.';
            console.error("SSE Error:", event);
        }

        // Ensure the connection is closed if not already
        if (evtSource.readyState !== EventSource.CLOSED) {
            evtSource.close();
        }
    };

    /**
     * Draws the current state of the array onto the canvas.
     * Highlights elements based on recent access or changes.
     * @param {number[]} arr - The array representing the data to visualize.
     * @param {Set<number>} accessedSet - Set of indices recently accessed.
     * @param {Set<number>} changedSet - Set of indices recently changed.
     * @param {boolean} [isFinishedState=false] - If true, all bars are drawn green.
     */
    function drawArray(arr, accessedSet, changedSet, isFinishedState = false) {
        // Clear the canvas before drawing
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Handle empty or invalid array gracefully
        if (!arr || arr.length === 0) {
            console.warn("drawArray called with empty or invalid array.");
            return;
        }

        // Calculate bar width based on canvas width and array length
        const barWidth = canvas.width / arr.length;
        const canvasHeight = canvas.height;

        // Find the maximum value in the array for scaling bar heights
        // Filter out non-numeric/infinite values before finding max
        let maxValue = 0;
        try {
            const numericValues = arr.filter(val => typeof val === 'number' && isFinite(val));
            maxValue = numericValues.length > 0 ? Math.max(...numericValues) : 1; // Use 1 if no valid numbers
        } catch (e) {
            maxValue = 1; // Fallback in case of unexpected errors
            console.error("Error finding max value:", e);
        }
        // Ensure maxValue is positive for scaling
        if (!isFinite(maxValue) || maxValue <= 0) maxValue = 1;


        // Iterate through the array elements and draw a bar for each
        for (let i = 0; i < arr.length; i++) {
            // Determine bar color based on priority: Finished > Changed > Accessed > Default
            if (isFinishedState) {
                ctx.fillStyle = COLOR_FINISHED;
            } else if (changedSet.has(i)) { // Recently changed? -> Red
                ctx.fillStyle = COLOR_CHANGED;
            } else if (accessedSet.has(i)) { // Recently accessed? -> Yellow
                ctx.fillStyle = COLOR_ACCESSED;
            } else { // Default color
                ctx.fillStyle = COLOR_DEFAULT;
            }

            // Calculate bar height based on the element's value relative to maxValue
            // Ensure value is a valid number, default to 0 if not
            const value = typeof arr[i] === 'number' && isFinite(arr[i]) ? arr[i] : 0;
            // Calculate height ratio (handle maxValue being 0)
            const valueRatio = maxValue === 0 ? 0 : (value / maxValue);
            // Calculate bar height, scale slightly below canvas height, ensure non-negative
            const barHeightUncapped = valueRatio * canvasHeight * 0.98; // Use 98% of height
            const barHeight = Math.max(0, barHeightUncapped); // Ensure height is >= 0

            // Calculate position and width for the bar
            const xPos = i * barWidth;
            // Ensure a minimum width of 1px and add a small gap between bars
            const actualBarWidth = Math.max(1, barWidth - 1); // Gap of 1px
            const yPos = canvasHeight - barHeight; // Y position starts from bottom

            // Final safety check for valid drawing parameters
            if (isFinite(xPos) && isFinite(yPos) && isFinite(actualBarWidth) && isFinite(barHeight) &&
                actualBarWidth > 0 && barHeight >= 0) {
                ctx.fillRect(xPos, yPos, actualBarWidth, barHeight);
            } else {
                // Log warning if drawing parameters are invalid, skip drawing this bar
                console.warn(`Skipping invalid rect draw: i=${i}, x=${xPos}, y=${yPos}, w=${actualBarWidth}, h=${barHeight}, val=${value}, max=${maxValue}`);
            }
        }
    }

    // Optional: Add a resize handler if the canvas size should be dynamic
    // window.addEventListener('resize', () => {
    //     // Adjust canvas size (consider aspect ratio, parent size)
    //     // canvas.width = ...; canvas.height = ...;
    //     // Redraw the last known state if available
    //     if (lastReceivedData) {
    //         try {
    //              const stepData = JSON.parse(lastReceivedData);
    //              drawArray(stepData.currentArray, new Set(recentlyAccessedIndices), new Set(recentlyChangedIndices), isFinished);
    //         } catch(e) {}
    //     }
    // });

</script>
</body>
</html>