<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Sortier-Visualisierung</title>
    <link rel="stylesheet" href="visualizer.css" />
</head>
<body>
<canvas id="canvas" width="600" height="298"></canvas>
<p id="status">Status: Connecting...</p>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusElement = document.getElementById('status');

    // Parameter aus Query-Parametern lesen
    const params = new URLSearchParams(window.location.search);
    const algorithm = params.get('algo');
    const dataset = params.get('dataset');
    const speed = params.get('speed');

    // URL für EventSource dynamisch bauen
    let url = `/api/compare/visualizer/${algorithm}`;
    const queryParams = [];
    if (dataset) {
        queryParams.push(`dataset=${encodeURIComponent(dataset)}`);
    }
    if (speed) {
        queryParams.push(`speed=${speed}`);
    }
    if (queryParams.length > 0) {
        url += `?${queryParams.join('&')}`;
    }

    // Timer, Status Logik und Daten-Check
    let startTime = null;
    let timerId = null;
    let lastReceivedData = null;
    let isFinished = false; // Flag für Beendigung

    function updateElapsedTime() {
        if (!startTime || isFinished) return;
        const now = Date.now();
        const elapsedSeconds = ((now - startTime) / 1000).toFixed(1);
        statusElement.textContent = `Status: Running... Elapsed: ${elapsedSeconds}s`;
    }

    // SSE-Verbindung zum Backend
    statusElement.textContent = 'Status: Connecting...';
    const evtSource = new EventSource(url);

    // onopen Handler
    evtSource.onopen = function() {
        startTime = Date.now();
        statusElement.textContent = 'Status: Running... Elapsed: 0.0s';
        timerId = setInterval(updateElapsedTime, 100);
        lastReceivedData = null;
        isFinished = false; // Zurücksetzen bei neuer Verbindung
    };

    // onmessage Handler
    evtSource.onmessage = function(e) {
        if (isFinished) {
            // console.log("Skipping message, already finished.");
            return;
        }
        if (e.data === lastReceivedData) {
            return;
        }
        lastReceivedData = e.data;

        try {
            const arr = JSON.parse(e.data);
            drawArray(arr);
        } catch (error) {
            console.error("Failed to parse SSE data:", error, e.data);
            statusElement.textContent = 'Status: Error parsing data!';
            if (timerId) clearInterval(timerId);
            isFinished = true; // Bei Fehler als beendet markieren
            evtSource.close();
        }
    };

    // onerror Handler
    evtSource.onerror = function(event) {
        isFinished = true; // Sicherstellen, dass Flag gesetzt ist
        if (timerId) clearInterval(timerId); // Timer immer stoppen

        if (evtSource.readyState === EventSource.CLOSED || event.eventPhase === EventSource.CLOSED) {
            if (startTime) {
                const finalElapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
                statusElement.textContent = `Status: Finished in ${finalElapsedSeconds}s`;
            } else {
                statusElement.textContent = 'Status: Finished (connection closed)';
            }
            // Letzten Zustand nochmal zeichnen
            if(lastReceivedData) { try { drawArray(JSON.parse(lastReceivedData)); } catch(e){ console.error("Error drawing final state:", e); } }
        } else {
            statusElement.textContent = 'Status: Error or disconnected.';
            console.error("SSE Error:", event);
        }

        if (evtSource.readyState !== EventSource.CLOSED) {
            evtSource.close();
        }
    };


    function drawArray(arr) {
        // Die Prüfung 'if (isFinished)' ist hier nicht unbedingt nötig, da 'onmessage' blockiert,
        // schadet aber auch nicht als zusätzliche Sicherheit.

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const w = canvas.width / arr.length;
        const maxHeight = canvas.height; // Nutzt die (leicht reduzierte) Canvas-Höhe

        let maxValue = 0;
        if (arr.length > 0) {
            // Sicherere Methode für große Arrays
            maxValue = arr.reduce((max, val) => Math.max(max, val), arr[0]);
        }
        // Verhindert Division durch Null, falls alle Werte 0 sind oder Array leer ist
        if (maxValue === 0) maxValue = 1;

        for (let i = 0; i < arr.length; i++) {
            ctx.fillStyle = 'steelblue';
            // Relative Skalierung (wie bereits vorhanden)
            const barHeight = (arr[i] / maxValue) * maxHeight * 0.98; // Kleiner Faktor für Rand oben
            // Zeichne von unten nach oben
            ctx.fillRect(i * w, canvas.height - barHeight, w - 2, barHeight);
        }
    }
</script>
</body>
</html>