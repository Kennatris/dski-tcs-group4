<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <title>Sortieralgorithmen vergleichen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="compare.css" />
</head>
<body>
<h1>Vergleich von zwei Sortieralgorithmen</h1>

<div class="center">
    <label>Datensatz-Auswahl</label>
    <select id="datasetSelect"></select>

    <div class="options-grid">
        <div>
            <label for="elementCount">Anzahl Elemente (für Datensätze)</label>
            <input type="number" id="elementCount" value="1000" min="100" max="1000000">
        </div>
        <div>
            <label for="vizSpeed">Visualisierungs-Pause (ms)</label>
            <div>
                <input type="number" id="vizSpeed" value="0" min="0" max="1000">
            </div>
        </div>
    </div>
</div>

<div class="grid">
    <div>
        <label>Algorithmus A</label>
        <select id="algoA"></select>
        <iframe id="frameA" title="Algorithmus A Visualisierung"></iframe>
    </div>
    <div>
        <label>Algorithmus B</label>
        <select id="algoB"></select>
        <iframe id="frameB" title="Algorithmus B Visualisierung"></iframe>
    </div>
</div>

<div class="center">
    <button id="compareBtn">Vergleichen</button>
    <p id="status" class="loading" style="display:none;">Sortiere Daten...</p>
</div>

<table id="resultTable" style="display:none">
    <thead>
    <tr>
        <th>Algorithmus</th>
        <th>Laufzeit (ms)</th>
        <th>Steps</th>
        <th>Unsortiertes Array</th>
        <th>Sortiertes Ergebnis</th>
        <th>Worst Case</th>
        <th>Average Case</th>
        <th>Best Case</th>
    </tr>
    </thead>
    <tbody></tbody>
</table>

<script>
    /**
     * Hauptskript für die Seite "Vergleich von zwei Sortieralgorithmen".
     * ...
     */

    let datasets = {};

    // --- START DER ÄNDERUNG (Neuer Speicher für Algo-Details) ---
    // Speichert alle Algorithmus-Details (Name, WorstCase etc.)
    let algorithmDetails = {};
    // --- ENDE DER ÄNDERUNG ---


    // --- 1️⃣ Lade verfügbare Sortieralgorithmen vom Backend ---
    /**
     * loadAlgorithms()
     * - (NEU) Ruft jetzt eine Liste von Objekten ab (Name, WorstCase, ...)
     * - (NEU) Speichert diese Details in 'algorithmDetails'
     * - Füllt die Select-Boxen
     */
    async function loadAlgorithms() {
        try {
            const res = await fetch('/api/compare/algorithms');
            if (!res.ok) throw new Error(`Fehler beim Laden der Algorithmen: ${res.status} ${res.statusText}`);

            // Erwartet: JSON-Antwort, z.B.
            // [ { "name": "BubbleSort", "worstCase": "O(n²)", ... }, ... ]
            const algos = await res.json();

            // Referenzen auf die Select-Elemente
            const selectA = document.getElementById('algoA');
            const selectB = document.getElementById('algoB');
            selectA.innerHTML = '';
            selectB.innerHTML = '';

            // NEU: algorithmDetails leeren
            algorithmDetails = {};

            // Neue Optionen hinzufügen
            for (const algo of algos) {
                // NEU: Details im globalen Objekt speichern
                algorithmDetails[algo.name] = algo;

                const optionA = document.createElement('option');
                optionA.value = algo.name; // Wert ist der Name
                optionA.textContent = algo.name; // Text ist der Name
                selectA.appendChild(optionA);

                const optionB = document.createElement('option');
                optionB.value = algo.name;
                optionB.textContent = algo.name;
                selectB.appendChild(optionB);
            }

            if (algos.length >= 2) {
                selectA.selectedIndex = 0;
                selectB.selectedIndex = 1;
            } else if (algos.length === 1) {
                selectA.selectedIndex = 0;
                selectB.selectedIndex = 0;
            }
        } catch (err) {
            console.error('Fehler beim Laden der Algorithmen:', err);
        }
    }

    // --- 2️⃣ Lade Datensätze vom Backend ---
    /**
     * loadDatasets()
     * - Validiert die Elementanzahl. Bei Fehlern wird 100 verwendet und ein Alert gezeigt.
     */
    async function loadDatasets() {

        const countInput = document.getElementById('elementCount');
        let elementCount = parseInt(countInput.value, 10);
        const minCount = 100;
        const maxCount = 1000000;

        if (isNaN(elementCount) || elementCount < minCount || elementCount > maxCount) {
            alert(`Ungültige Elementanzahl. Die Anzahl muss zwischen ${minCount} und ${maxCount} liegen. Setze auf 100 zurück.`);
            elementCount = 100;
            countInput.value = 100;
        }

        try {
            const res = await fetch(`/api/compare/datasets?count=${elementCount}`);
            if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);

            const data = await res.json();
            datasets = data || {};
            const sel = document.getElementById('datasetSelect');
            sel.innerHTML = '';

            for (const key of Object.keys(datasets)) {
                const opt = document.createElement('option');
                opt.value = key;
                opt.textContent = key
                    .replace(/([A-Z])/g, ' $1')
                    .replace(/^./, str => str.toUpperCase());
                sel.appendChild(opt);
            }

            if (sel.options.length > 0) sel.selectedIndex = 0;
        } catch (err) {
            console.error("Fehler beim Laden der Datensätze:", err);
        }
    }

    // --- 3️⃣ Vergleich ausführen ---
    /**
     * compare()
     * - (NEU) Prüft die Worst-Case-Laufzeit und Elementanzahl VOR dem Fetch.
     * - (NEU) Zeigt eine confirm()-Warnung, wenn die Kombination langsam sein könnte.
     */
    async function compare() {
        const status = document.getElementById('status');

        // --- START DER ÄNDERUNG (Warnungs-Logik) ---

        // 1. Daten für die Warnung sammeln
        const algoA_name = document.getElementById('algoA').value;
        const algoB_name = document.getElementById('algoB').value;
        const elementCount = parseInt(document.getElementById('elementCount').value, 10);

        const detailsA = algorithmDetails[algoA_name];
        const detailsB = algorithmDetails[algoB_name];

        let showWarning = false;
        let warningReason = "";

        // Prüfe, ob die Details geladen wurden (sollte immer der Fall sein)
        if (detailsA && detailsB) {
            const worstA = detailsA.worstCase;
            const worstB = detailsB.worstCase;

            // Definition von "langsamen" Komplexitäten
            const slowComplexities = ["O(n²)", "O(n^(3/2))"];

            // Definition von "sehr großen" Datenmengen (für O(n²) usw.)
            const largeN = 20000;

            // Prüflogik
            if (worstA.includes("∞") || worstB.includes("∞")) {
                showWarning = true;
                warningReason = "Ein Algorithmus mit O(∞) (z.B. BogoSort) wird fast sicher nicht fertig.";
            } else if (elementCount > largeN &&
                (slowComplexities.some(c => worstA.includes(c)) ||
                    slowComplexities.some(c => worstB.includes(c))) )
            {
                showWarning = true;
                warningReason = `Sie führen einen O(n²) Algorithmus mit einer großen Datenmenge (n > ${largeN}) aus. Dies kann sehr lange dauern.`;
            }
        }

        // 2. Warnung anzeigen und ggf. abbrechen
        if (showWarning) {
            const proceed = confirm(`WARNUNG:\n${warningReason}\n\Möchten Sie den Vergleich trotzdem starten?`);
            if (!proceed) {
                status.style.display = 'none'; // Status ausblenden
                return; // Funktion abbrechen
            }
        }
        // --- ENDE DER ÄNDERUNG (Warnungs-Logik) ---


        // Ladehinweis anzeigen (jetzt erst, nach der Bestätigung)
        status.style.display = 'inline';
        status.textContent = "Sortiere Daten...";

        try {
            const datasetKey = document.getElementById('datasetSelect').value;

            // Validierung für Speed (von vorheriger Anfrage)
            const speedInput = document.getElementById('vizSpeed');
            let vizSpeed = parseInt(speedInput.value, 10);
            const minSpeed = 0;
            const maxSpeed = 1000;

            if (isNaN(vizSpeed) || vizSpeed < minSpeed || vizSpeed > maxSpeed) {
                alert(`Ungültige Pausenzeit. Die Zeit muss zwischen ${minSpeed}ms und ${maxSpeed}ms liegen. Setze auf 0ms zurück.`);
                vizSpeed = 0;
                speedInput.value = 0;
            }

            const inputData = datasets[datasetKey];
            if (!inputData) {
                alert("Fehler: Kein Datensatz ausgewählt!");
                return;
            }

            // Payload (unverändert)
            const payload = {
                algorithms: [algoA_name, algoB_name],
                input: inputData
            };

            // POST-Request (unverändert)
            const res = await fetch('/api/compare', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!res.ok) throw new Error(`Fehler beim Vergleich: ${res.status} ${res.statusText}`);

            // Ergebnis-Tabelle füllen (unverändert)
            const data = await res.json();
            const table = document.getElementById('resultTable');
            const tbody = table.querySelector('tbody');
            tbody.innerHTML = '';

            data.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${row.algorithm ?? '-'}</td>
                    <td>${row.durationMillis ?? '-'}</td>
                    <td>${row.steps ?? '-'}</td>
                    <td>${(row.unsorted || []).join(', ')}</td>
                    <td>${(row.sorted || []).join(', ')}</td>
                    <td>${row.worstCase ?? '-'}</td>
                    <td>${row.averageCase ?? '-'}</td>
                    <td>${row.bestCase ?? '-'}</td>
                `;
                tbody.appendChild(tr);
            });

            table.style.display = (data && data.length) ? 'table' : 'none';

            // IFrames aktualisieren (unverändert)
            const frameA = document.getElementById('frameA');
            const frameB = document.getElementById('frameB');

            frameA.src = `/visualizer.html?algo=${encodeURIComponent(algoA_name)}&dataset=${encodeURIComponent(datasetKey)}&speed=${vizSpeed}`;
            frameB.src = `/visualizer.html?algo=${encodeURIComponent(algoB_name)}&dataset=${encodeURIComponent(datasetKey)}&speed=${vizSpeed}`;

        } catch (err) {
            console.error("Fehler beim Vergleich:", err);
            alert("Fehler beim Vergleich: " + (err.message || err));
        } finally {
            status.style.display = 'none';
        }
    }

    // --- Event-Listener und Initialisierung ---
    document.getElementById('compareBtn').addEventListener('click', compare);
    document.getElementById('elementCount').addEventListener('change', loadDatasets);

    // Initiales Laden
    loadAlgorithms();
    loadDatasets();
</script>
</body>
</html>