<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <title>Sortieralgorithmen vergleichen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="compare.css" />

</head>
<body>
<h1>Vergleich von zwei Sortieralgorithmen</h1>

<div class="center">
    <label>Datensatz-Auswahl</label>
    <select id="datasetSelect"></select>

    <div class="options-grid">
        <div>
            <label for="elementCount">Anzahl Elemente (für Datensätze)</label>
            <input type="number" id="elementCount" value="1000" min="100" max="1000000">
        </div>
        <div>
            <label for="vizSpeed">Visualisierungs-Pause (ms)</label>
            <div>
                <input type="number" id="vizSpeed" value="0" min="0" max="1000">
            </div>
        </div>
    </div>
</div>

<div class="grid">
    <div>
        <label>Algorithmus A</label>
        <select id="algoA"></select>
        <iframe id="frameA" title="Algorithmus A Visualisierung"></iframe>
    </div>
    <div>
        <label>Algorithmus B</label>
        <select id="algoB"></select>
        <iframe id="frameB" title="Algorithmus B Visualisierung"></iframe>
    </div>
</div>

<div class="center">
    <button id="compareBtn">Vergleichen</button>
    <p id="status" class="loading" style="display:none;">Sortiere Daten...</p>
    <progress id="progressBar" value="0" max="100" style="display:none;"></progress>
</div>

<table id="resultTable" style="display:none">
    <thead>
    <tr>
        <th>Algorithmus</th>
        <th>Laufzeit (ms)</th>
        <th>Steps</th>
        <th>Unsortiertes Array</th>
        <th>Sortiertes Ergebnis</th>
        <th>Worst Case</th>
        <th>Average Case</th>
        <th>Best Case</th>
    </tr>
    </thead>
    <tbody></tbody>
</table>

<script>
    /**
     * Hauptskript für die Seite "Vergleich von zwei Sortieralgorithmen".
     * ...
     */

    let datasets = {};
    let algorithmDetails = {};

    // --- NEU: Status-Variablen für Abbruch-Logik ---
    let isComparing = false;
    let currentCompareController = null;
    let progressInterval = null;
    // --- ENDE NEU ---


    // --- 1️⃣ Lade verfügbare Sortieralgorithmen vom Backend ---
    async function loadAlgorithms() {
        try {
            const res = await fetch('/api/compare/algorithms');
            if (!res.ok) throw new Error(`Fehler beim Laden der Algorithmen: ${res.status} ${res.statusText}`);

            const algos = await res.json();
            const selectA = document.getElementById('algoA');
            const selectB = document.getElementById('algoB');
            selectA.innerHTML = '';
            selectB.innerHTML = '';
            algorithmDetails = {};

            for (const algo of algos) {
                algorithmDetails[algo.name] = algo;

                const optionA = document.createElement('option');
                optionA.value = algo.name;
                optionA.textContent = algo.name;
                selectA.appendChild(optionA);

                const optionB = document.createElement('option');
                optionB.value = algo.name;
                optionB.textContent = algo.name;
                selectB.appendChild(optionB);
            }

            if (algos.length >= 2) {
                selectA.selectedIndex = 0;
                selectB.selectedIndex = 1;
            } else if (algos.length === 1) {
                selectA.selectedIndex = 0;
                selectB.selectedIndex = 0;
            }
        } catch (err) {
            console.error('Fehler beim Laden der Algorithmen:', err);
        }
    }

    // --- 2️⃣ Lade Datensätze vom Backend ---
    async function loadDatasets() {
        const countInput = document.getElementById('elementCount');
        let elementCount = parseInt(countInput.value, 10);
        const minCount = 100;
        const maxCount = 1000000;

        if (isNaN(elementCount) || elementCount < minCount || elementCount > maxCount) {
            alert(`Ungültige Elementanzahl. Die Anzahl muss zwischen ${minCount} und ${maxCount} liegen. Setze auf 100 zurück.`);
            elementCount = 100;
            countInput.value = 100;
        }

        try {
            const res = await fetch(`/api/compare/datasets?count=${elementCount}`);
            if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);

            const data = await res.json();
            datasets = data || {};
            const sel = document.getElementById('datasetSelect');
            sel.innerHTML = '';

            for (const key of Object.keys(datasets)) {
                const opt = document.createElement('option');
                opt.value = key;
                opt.textContent = key
                    .replace(/([A-Z])/g, ' $1')
                    .replace(/^./, str => str.toUpperCase());
                sel.appendChild(opt);
            }

            if (sel.options.length > 0) sel.selectedIndex = 0;
        } catch (err) {
            console.error("Fehler beim Laden der Datensätze:", err);
        }
    }

    // --- 3️⃣ Vergleichs-Logik (Überarbeitet) ---

    /**
     * NEU: Funktion zum Zurücksetzen des UI-Status
     */
    function resetUI() {
        const status = document.getElementById('status');
        const compareBtn = document.getElementById('compareBtn');
        const progressBar = document.getElementById('progressBar');

        // Button zurücksetzen
        isComparing = false;
        compareBtn.textContent = 'Vergleichen';
        compareBtn.classList.remove('cancel-btn');

        // Anzeigen ausblenden
        status.style.display = 'none';
        progressBar.style.display = 'none';
        progressBar.value = 0;

        // Intervalle löschen
        if (progressInterval) {
            clearInterval(progressInterval);
            progressInterval = null;
        }

        // Controller zurücksetzen
        currentCompareController = null;
    }

    /**
     * NEU: Funktion zum Abbrechen des Vergleichs
     */
    function cancelCompare() {
        if (currentCompareController) {
            currentCompareController.abort();
            console.log("Vergleich abgebrochen.");
        }
        // resetUI() wird im 'finally' Block von startCompare() aufgerufen.
    }


    /**
     * NEU: Umbenannt zu startCompare(), enthält die Hauptlogik
     */
    async function startCompare() {
        // Referenzen holen
        const status = document.getElementById('status');
        const compareBtn = document.getElementById('compareBtn');
        const progressBar = document.getElementById('progressBar');
        const table = document.getElementById('resultTable');
        const frameA = document.getElementById('frameA');
        const frameB = document.getElementById('frameB');

        // --- 1. Vorherige Ergebnisse zurücksetzen ---
        table.style.display = 'none';
        frameA.src = 'about:blank';
        frameB.src = 'about:blank';
        if (table.querySelector('tbody')) {
            table.querySelector('tbody').innerHTML = '';
        }

        // --- 2. Warnungs-Logik (unverändert) ---
        const algoA_name = document.getElementById('algoA').value;
        const algoB_name = document.getElementById('algoB').value;
        const elementCount = parseInt(document.getElementById('elementCount').value, 10);
        const detailsA = algorithmDetails[algoA_name];
        const detailsB = algorithmDetails[algoB_name];
        let showWarning = false;
        let warningReason = "";

        if (detailsA && detailsB) {
            const worstA = detailsA.worstCase;
            const worstB = detailsB.worstCase;
            const slowComplexities = ["O(n²)", "O(n^(3/2))"];
            const largeN = 20000;

            if (worstA.includes("∞") || worstB.includes("∞")) {
                showWarning = true;
                warningReason = "Ein Algorithmus mit O(∞) (z.B. BogoSort) wird fast sicher nicht fertig.";
            } else if (elementCount > largeN &&
                (slowComplexities.some(c => worstA.includes(c)) ||
                    slowComplexities.some(c => worstB.includes(c))) )
            {
                showWarning = true;
                warningReason = `Sie führen einen O(n²) Algorithmus mit einer großen Datenmenge (n > ${largeN}) aus. Dies kann sehr lange dauern.`;
            }
        }

        if (showWarning) {
            const proceed = confirm(`WARNUNG:\n${warningReason}\n\Möchten Sie den Vergleich trotzdem starten?`);
            if (!proceed) {
                return; // Abbruch vor dem Start
            }
        }

        // --- 3. UI für "Laden" vorbereiten ---
        isComparing = true;
        currentCompareController = new AbortController();

        status.style.display = 'inline';
        status.textContent = "Sortiere Daten...";
        compareBtn.textContent = 'Abbruch';
        compareBtn.classList.add('cancel-btn');

        progressBar.style.display = 'block';
        progressBar.value = 0;

        // Startet die Fake-Progressbar
        progressInterval = setInterval(() => {
            if (progressBar.value < 90) {
                progressBar.value += 2; // Langsamer Anstieg
            }
        }, 100);


        // --- 4. Fetch-Logik ---
        try {
            const datasetKey = document.getElementById('datasetSelect').value;
            const speedInput = document.getElementById('vizSpeed');
            let vizSpeed = parseInt(speedInput.value, 10);
            const minSpeed = 0;
            const maxSpeed = 1000;

            if (isNaN(vizSpeed) || vizSpeed < minSpeed || vizSpeed > maxSpeed) {
                alert(`Ungültige Pausenzeit. Die Zeit muss zwischen ${minSpeed}ms und ${maxSpeed}ms liegen. Setze auf 0ms zurück.`);
                vizSpeed = 0;
                speedInput.value = 0;
            }

            const inputData = datasets[datasetKey];
            if (!inputData) {
                alert("Fehler: Kein Datensatz ausgewählt!");
                resetUI(); // UI zurücksetzen bei Fehler
                return;
            }

            const payload = {
                algorithms: [algoA_name, algoB_name],
                input: inputData
            };

            // Fetch mit Abbruch-Signal
            const res = await fetch('/api/compare', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
                signal: currentCompareController.signal // Signal für Abbruch
            });

            if (!res.ok) throw new Error(`Fehler beim Vergleich: ${res.status} ${res.statusText}`);

            // Progressbar auf fast fertig setzen, da Fetch abgeschlossen ist
            progressBar.value = 95;

            const data = await res.json();
            const tbody = table.querySelector('tbody');
            tbody.innerHTML = '';

            data.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${row.algorithm ?? '-'}</td>
                    <td>${row.durationMillis ?? '-'}</td>
                    <td>${row.steps ?? '-'}</td>
                    <td>${(row.unsorted || []).join(', ')}</td>
                    <td>${(row.sorted || []).join(', ')}</td>
                    <td>${row.worstCase ?? '-'}</td>
                    <td>${row.averageCase ?? '-'}</td>
                    <td>${row.bestCase ?? '-'}</td>
                `;
                tbody.appendChild(tr);
            });

            table.style.display = (data && data.length) ? 'table' : 'none';

            // IFrames aktualisieren
            frameA.src = `/visualizer.html?algo=${encodeURIComponent(algoA_name)}&dataset=${encodeURIComponent(datasetKey)}&speed=${vizSpeed}`;
            frameB.src = `/visualizer.html?algo=${encodeURIComponent(algoB_name)}&dataset=${encodeURIComponent(datasetKey)}&speed=${vizSpeed}`;

            progressBar.value = 100; // Fertig

        } catch (err) {
            // NEU: Abfrage auf Abbruch-Fehler
            if (err.name === 'AbortError') {
                console.log("Fetch abgebrochen.");
                // Tabelle und iFrames wurden bereits am Anfang von startCompare() geleert.
            } else {
                console.error("Fehler beim Vergleich:", err);
                alert("Fehler beim Vergleich: " + (err.message || err));
            }
        } finally {
            // NEU: resetUI() wird immer aufgerufen, egal ob Erfolg, Fehler oder Abbruch
            resetUI();
        }
    }

    // --- Event-Listener und Initialisierung ---

    // NEU: Der Button-Listener prüft jetzt den Status
    document.getElementById('compareBtn').addEventListener('click', () => {
        if (isComparing) {
            cancelCompare();
        } else {
            startCompare();
        }
    });

    document.getElementById('elementCount').addEventListener('change', loadDatasets);

    // Initiales Laden
    loadAlgorithms();
    loadDatasets();
</script>
</body>
</html>