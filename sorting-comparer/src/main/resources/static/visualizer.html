<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Sortier-Visualisierung</title>
    <link rel="stylesheet" href="visualizer.css" />
</head>
<body>
<canvas id="canvas" width="600" height="298"></canvas>
<p id="status">Status: Connecting...</p>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusElement = document.getElementById('status');

    // Parameter aus Query-Parametern lesen
    const params = new URLSearchParams(window.location.search);
    const algorithm = params.get('algo');
    const dataset = params.get('dataset');
    const speed = params.get('speed');
    // --- NEUE ÄNDERUNG ---
    const count = params.get('count'); // Lese den neuen 'count' Parameter
    // --- ENDE NEU ---

    // URL für EventSource dynamisch bauen
    let url = `/api/compare/visualizer/${algorithm}`;
    const queryParams = [];
    if (dataset) {
        queryParams.push(`dataset=${encodeURIComponent(dataset)}`);
    }
    if (speed) {
        queryParams.push(`speed=${speed}`);
    }
    // --- NEUE ÄNDERUNG ---
    if (count) {
        queryParams.push(`count=${encodeURIComponent(count)}`); // Füge 'count' zur API-URL hinzu
    }
    // --- ENDE NEU ---

    if (queryParams.length > 0) {
        url += `?${queryParams.join('&')}`;
    }

    // Timer, Status Logik und Daten-Check
    let startTime = null;
    let timerId = null;
    let lastReceivedData = null;
    let isFinished = false;

    // Variablen für Änderungs-Hervorhebung
    let previousArr = [];
    let lastChangedIndices = [];
    const HIGHLIGHT_COUNT = 6;

    function updateElapsedTime() {
        if (!startTime || isFinished) return;
        const now = Date.now();
        const elapsedSeconds = ((now - startTime) / 1000).toFixed(1);
        statusElement.textContent = `Status: Running... Elapsed: ${elapsedSeconds}s`;
    }

    // SSE-Verbindung zum Backend
    statusElement.textContent = 'Status: Connecting...';
    const evtSource = new EventSource(url);

    // onopen Handler
    evtSource.onopen = function() {
        startTime = Date.now();
        statusElement.textContent = 'Status: Running... Elapsed: 0.0s';
        timerId = setInterval(updateElapsedTime, 100);
        lastReceivedData = null;
        isFinished = false;

        previousArr = [];
        lastChangedIndices = [];
    };

    // onmessage Handler
    evtSource.onmessage = function(e) {
        if (isFinished) {
            return;
        }
        if (e.data === lastReceivedData) {
            return;
        }
        lastReceivedData = e.data;

        try {
            const arr = JSON.parse(e.data);

            if (previousArr.length === 0) {
                previousArr = [...arr];
            }

            const currentChanged = new Set();
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] !== previousArr[i]) {
                    lastChangedIndices.push(i);
                    currentChanged.add(i);
                }
            }

            while (lastChangedIndices.length > HIGHLIGHT_COUNT) {
                lastChangedIndices.shift();
            }

            previousArr = [...arr];

            drawArray(arr, new Set(lastChangedIndices), false);

        } catch (error) {
            console.error("Failed to parse SSE data:", error, e.data);
            statusElement.textContent = 'Status: Error parsing data!';
            if (timerId) clearInterval(timerId);
            isFinished = true;
            evtSource.close();
        }
    };

    // onerror Handler
    evtSource.onerror = function(event) {
        isFinished = true;
        if (timerId) clearInterval(timerId);

        if (evtSource.readyState === EventSource.CLOSED || event.eventPhase === EventSource.CLOSED) {
            if (startTime) {
                const finalElapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
                statusElement.textContent = `Status: Finished in ${finalElapsedSeconds}s`;
            } else {
                statusElement.textContent = 'Status: Finished (connection closed)';
            }

            if(lastReceivedData) {
                try {
                    drawArray(JSON.parse(lastReceivedData), new Set(), true);
                } catch(e){
                    console.error("Error drawing final state:", e);
                }
            }
        } else {
            statusElement.textContent = 'Status: Error or disconnected.';
            console.error("SSE Error:", event);
        }

        if (evtSource.readyState !== EventSource.CLOSED) {
            evtSource.close();
        }
    };


    /**
     * @param {number[]} arr Das zu zeichnende Array
     * @param {Set<number>} changedSet Ein Set von Indizes, die rot hervorgehoben werden sollen
     * @param {boolean} isFinishedState Wenn true, wird alles grün gezeichnet
     */
    function drawArray(arr, changedSet, isFinishedState = false) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const w = canvas.width / arr.length;
        const maxHeight = canvas.height;

        let maxValue = 0;
        if (arr.length > 0) {
            maxValue = arr.reduce((max, val) => Math.max(max, val), arr[0]);
        }
        if (maxValue === 0) maxValue = 1;

        for (let i = 0; i < arr.length; i++) {

            if (isFinishedState) {
                ctx.fillStyle = '#28a745'; // Grün für "Fertig"
            } else if (changedSet.has(i)) {
                ctx.fillStyle = '#dc3545'; // Rot (Hervorhebung)
            } else {
                ctx.fillStyle = 'steelblue'; // Standard Blau
            }

            const barHeight = (arr[i] / maxValue) * maxHeight * 0.98;
            ctx.fillRect(i * w, canvas.height - barHeight, w - 2, barHeight);
        }
    }
</script>
</body>
</html>