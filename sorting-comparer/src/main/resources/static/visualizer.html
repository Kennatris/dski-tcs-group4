<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Sortier-Visualisierung</title>
    <link rel="stylesheet" href="visualizer.css" />
</head>
<body>
<canvas id="canvas" width="600" height="298"></canvas>
<p id="status">Status: Connecting...</p>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusElement = document.getElementById('status');

    const params = new URLSearchParams(window.location.search);
    const algorithm = params.get('algo');
    const dataset = params.get('dataset');
    const speed = params.get('speed');
    const count = params.get('count');

    let url = `/api/compare/visualizer/${algorithm}`;
    const queryParams = [];
    if (dataset) queryParams.push(`dataset=${encodeURIComponent(dataset)}`);
    if (speed) queryParams.push(`speed=${speed}`);
    if (count) queryParams.push(`count=${encodeURIComponent(count)}`);
    if (queryParams.length > 0) url += `?${queryParams.join('&')}`;

    let startTime = null;
    let timerId = null;
    let lastReceivedData = null; // Speichert das rohe JSON des letzten Schritts
    let lastProcessedArrayState = null; // Speichert nur den Array-Teil des letzten verarbeiteten Schritts
    let isFinished = false;

    // --- Separate Historien für Hervorhebungen ---
    let recentlyChangedIndices = []; // Letzte 6 Änderungen (Rot)
    let recentlyAccessedIndices = []; // Letzte 6 Zugriffe (Gelb)
    const HIGHLIGHT_COUNT = 6; // Anzahl der zu merkenden Indizes

    // --- Farbkonstanten ---
    const COLOR_FINISHED = '#28a745'; // Grün
    const COLOR_CHANGED = '#dc3545';  // Rot
    const COLOR_ACCESSED = '#ffc107'; // Gelb
    const COLOR_DEFAULT = 'steelblue'; // Blau

    /**
     * Aktualisiert die Anzeige der verstrichenen Zeit.
     */
    function updateElapsedTime() {
        if (!startTime || isFinished) return;
        const now = Date.now();
        const elapsedSeconds = ((now - startTime) / 1000).toFixed(1);
        statusElement.textContent = `Status: Running... Elapsed: ${elapsedSeconds}s`;
    }

    /**
     * Fügt neue Indizes zu einer Highlight-Liste hinzu und hält sie auf maximaler Länge.
     * @param {number[]} indexList Die Liste, die aktualisiert werden soll (z.B. recentlyChangedIndices).
     * @param {number[]} newIndices Die neuen Indizes aus dem aktuellen Schritt.
     */
    function updateHighlightList(indexList, newIndices) {
        newIndices.forEach(index => {
            // Entferne den Index, falls er schon existiert, um ihn ans Ende zu schieben
            const existingPos = indexList.indexOf(index);
            if (existingPos > -1) {
                indexList.splice(existingPos, 1);
            }
            // Füge den neuen Index am Ende hinzu
            indexList.push(index);
        });
        // Kürze die Liste von vorne, falls sie zu lang wird
        while (indexList.length > HIGHLIGHT_COUNT) {
            indexList.shift();
        }
    }


    statusElement.textContent = 'Status: Connecting...';
    const evtSource = new EventSource(url);

    /**
     * Event-Handler beim Öffnen der SSE-Verbindung.
     */
    evtSource.onopen = function() {
        startTime = Date.now();
        statusElement.textContent = 'Status: Running... Elapsed: 0.0s';
        timerId = setInterval(updateElapsedTime, 100);
        lastReceivedData = null;
        lastProcessedArrayState = null;
        isFinished = false;
        recentlyChangedIndices = []; // Zurücksetzen
        recentlyAccessedIndices = []; // Zurücksetzen
    };

    /**
     * Event-Handler für eingehende SSE-Nachrichten (SortSteps).
     */
    evtSource.onmessage = function(e) {
        if (isFinished) return;

        // Verhindere Verarbeitung identischer Rohdaten
        if (e.data === lastReceivedData) return;
        lastReceivedData = e.data;

        try {
            const stepData = JSON.parse(e.data);
            const arr = stepData.currentArray;
            // Lese die Indizes aus dem Schritt, Fallback auf leere Arrays
            const currentAccessed = stepData.accessedIndices || [];
            const currentChanged = stepData.changedIndices || [];

            if (!arr) {
                console.warn("Received stepData, but 'currentArray' field was missing.", stepData);
                return;
            }

            // Optional: Verhindere Neuzeichnen, wenn sich nur Highlights ändern
            // if (JSON.stringify(arr) === lastProcessedArrayState) return;
            // lastProcessedArrayState = JSON.stringify(arr);


            // --- Aktualisiere die Highlight-Listen ---
            updateHighlightList(recentlyChangedIndices, currentChanged);
            updateHighlightList(recentlyAccessedIndices, currentAccessed);


            // --- Zeichne mit den aktualisierten Highlight-Listen ---
            drawArray(arr, new Set(recentlyAccessedIndices), new Set(recentlyChangedIndices), false);

        } catch (error) {
            console.error("Failed to parse SSE data:", error, e.data);
            statusElement.textContent = 'Status: Error parsing data!';
            if (timerId) clearInterval(timerId);
            isFinished = true;
            evtSource.close();
        }
    };

    /**
     * Event-Handler für Fehler oder Schließen der SSE-Verbindung.
     */
    evtSource.onerror = function(event) {
        isFinished = true;
        if (timerId) clearInterval(timerId);

        if (evtSource.readyState === EventSource.CLOSED || event.eventPhase === EventSource.CLOSED) {
            if (startTime) {
                const finalElapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
                statusElement.textContent = `Status: Finished in ${finalElapsedSeconds}s`;
            } else {
                statusElement.textContent = 'Status: Finished (connection closed)';
            }

            // Zeichne den letzten bekannten Zustand grün
            if(lastReceivedData) {
                try {
                    const stepData = JSON.parse(lastReceivedData);
                    const arr = stepData.currentArray;
                    if (arr) {
                        // Keine Highlights im Endzustand
                        drawArray(arr, new Set(), new Set(), true);
                    }
                } catch(e){
                    console.error("Error drawing final state:", e);
                }
            }
        } else {
            statusElement.textContent = 'Status: Error or disconnected.';
            console.error("SSE Error:", event);
        }

        if (evtSource.readyState !== EventSource.CLOSED) {
            evtSource.close();
        }
    };

    /**
     * Zeichnet das Array auf den Canvas mit Farb-Priorisierung (Grün > Rot > Gelb > Blau).
     * @param {number[]} arr Das zu zeichnende Array.
     * @param {Set<number>} accessedSet Set der Indizes aus den letzten Schritten, die angeschaut wurden (gelb).
     * @param {Set<number>} changedSet Set der Indizes aus den letzten Schritten, die geändert wurden (rot).
     * @param {boolean} isFinishedState Wenn true, wird alles grün gezeichnet.
     */
    function drawArray(arr, accessedSet, changedSet, isFinishedState = false) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Schutz gegen leeres oder ungültiges Array
        if (!arr || arr.length === 0) {
            return;
        }
        const w = canvas.width / arr.length;
        const maxHeight = canvas.height;

        let maxValue = 0;
        try {
            maxValue = Math.max(...arr.filter(val => typeof val === 'number' && isFinite(val))); // Finde Max nur von gültigen Zahlen
        } catch (e) {
            // Fallback, falls arr keine gültigen Zahlen enthält
            maxValue = 1;
        }
        if (!isFinite(maxValue) || maxValue <= 0) maxValue = 1; // Fallback, falls Max 0, negativ oder ungültig ist


        for (let i = 0; i < arr.length; i++) {
            // Farb-Priorität: Grün > Rot > Gelb > Blau
            if (isFinishedState) {
                ctx.fillStyle = COLOR_FINISHED;
            } else if (changedSet.has(i)) { // Kürzlich geändert? -> Rot
                ctx.fillStyle = COLOR_CHANGED;
            } else if (accessedSet.has(i)) { // Kürzlich angeschaut? -> Gelb
                ctx.fillStyle = COLOR_ACCESSED;
            } else { // Standard
                ctx.fillStyle = COLOR_DEFAULT;
            }

            // Zeichne den Balken
            const val = typeof arr[i] === 'number' && isFinite(arr[i]) ? arr[i] : 0; // Sicherstellen, dass val eine Zahl ist
            const valueRatio = maxValue === 0 ? 0 : (val / maxValue);
            const barHeightUncapped = valueRatio * maxHeight * 0.98;
            const barHeight = Math.max(0, barHeightUncapped); // Höhe >= 0

            const xPos = i * w;
            const barWidth = Math.max(1, w - 2); // Mindestbreite 1px
            const yPos = canvas.height - barHeight;

            // Finale Prüfung vor dem Zeichnen
            if (isFinite(xPos) && isFinite(yPos) && isFinite(barWidth) && isFinite(barHeight) && barWidth > 0 && barHeight >= 0) {
                ctx.fillRect(xPos, yPos, barWidth, barHeight);
            } else {
                console.warn(`Skipping invalid rect draw: i=${i}, x=${xPos}, y=${yPos}, w=${barWidth}, h=${barHeight}, val=${val}, max=${maxValue}`);
            }
        }
    }
</script>
</body>
</html>