<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <title>Sortieralgorithmen vergleichen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="compare.css" />
    <style>
        /* Zusätzliche Stile für die Suchergebnislisten */
        .search-results { /* Klasse statt ID für Wiederverwendbarkeit */
            border: 1px solid #ccc;
            max-height: 200px;
            overflow-y: auto;
            position: absolute; /* Positioniert die Liste unter dem Suchfeld */
            background-color: white;
            z-index: 1000; /* Stellt sicher, dass die Liste über anderen Elementen liegt */
            width: calc(100% - 1.2rem); /* Passt Breite an (ggf. anpassen) */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-top: 2px; /* Kleiner Abstand zum Suchfeld */
        }
        .search-result-item {
            padding: 8px 12px;
            cursor: pointer; /* Gesamtes Element klickbar machen */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .search-result-item:hover {
            background-color: #f0f0f0;
        }
        .search-result-item span {
            flex-grow: 1;
            margin-right: 10px;
        }
        /* Container für Suche und Ergebnisliste */
        .search-container {
            position: relative; /* Wichtig für absolute Positionierung der Ergebnisliste */
            margin-bottom: 1rem; /* Abstand nach unten */
        }
        /* Progress Bar Animation */
        @keyframes progress-bar-stripes {
            from { background-position: 1rem 0; }
            to { background-position: 0 0; }
        }

        #progressBar {
            width: 60%;
            margin-top: 1rem;
            height: 12px;
            margin-left: auto;
            margin-right: auto;
            appearance: none;
            border: 1px solid #ccc;
            border-radius: 5px;
            overflow: hidden;
            /* Standardmäßig ausgeblendet, wird per JS gesteuert */
            display: none;
        }

        #progressBar::-webkit-progress-bar {
            background-color: #f5f5f5;
            border-radius: 5px;
        }

        #progressBar::-webkit-progress-value {
            background-color: #007bff;
            background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
            transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
            transparent 75%, transparent);
            background-size: 1rem 1rem;
            animation: progress-bar-stripes 1s linear infinite;
            transition: width 0.1s ease; /* Glättet Wertänderungen */
        }

        #progressBar::-moz-progress-bar {
            background-color: #007bff;
            background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
            transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
            transparent 75%, transparent);
            background-size: 1rem 1rem;
            animation: progress-bar-stripes 1s linear infinite;
            transition: width 0.1s ease;
        }
        /* Styles, um Tabelle und Iframes initial auszublenden */
        #resultTable, #frameA, #frameB {
            display: none; /* Initial komplett ausgeblendet */
        }

    </style>
</head>
<body>
<h1>Vergleich von zwei Sortieralgorithmen</h1>

<div class="center">
    <label for="datasetSelect">Datensatz-Auswahl</label>
    <select id="datasetSelect"></select>

    <div class="options-grid">
        <div>
            <label for="elementCount">Anzahl Elemente (für Datensätze)</label>
            <input type="number" id="elementCount" value="1000" min="5" max="1000000">
        </div>
        <div>
            <label for="vizSpeed">Visualisierungs-Pause (ms)</label>
            <input type="number" id="vizSpeed" value="0" min="0" max="1000">
        </div>
    </div>
</div>

<div class="grid">
    <div>
        <label for="searchInputA">Algorithmus A</label>
        <div class="search-container">
            <input type="text" id="searchInputA" placeholder="Suchen..." autocomplete="off">
            <div id="searchResultsA" class="search-results" style="display: none;"></div>
        </div>
        <iframe id="frameA" title="Algorithmus A Visualisierung"></iframe>
    </div>
    <div>
        <label for="searchInputB">Algorithmus B</label>
        <div class="search-container">
            <input type="text" id="searchInputB" placeholder="Suchen..." autocomplete="off">
            <div id="searchResultsB" class="search-results" style="display: none;"></div>
        </div>
        <iframe id="frameB" title="Algorithmus B Visualisierung"></iframe>
    </div>
</div>


<div class="center">
    <button id="compareBtn">Vergleichen</button>
    <p id="status" class="loading" style="display:none;">Sortiere Daten...</p>
    <progress id="progressBar" value="0" max="100"></progress>
</div>

<table id="resultTable">
    <thead>
    <tr>
        <th>Algorithmus</th>
        <th>Laufzeit (ms)</th>
        <th>Steps</th>
        <th>Unsortiertes Array</th>
        <th>Sortiertes Ergebnis</th>
        <th>Worst Case</th>
        <th>Average Case</th>
        <th>Best Case</th>
    </tr>
    </thead>
    <tbody></tbody>
</table>

<script>
    // Globale Variablen (wie zuvor)
    let datasets = {};
    let algorithmDetails = {};
    let allAlgorithmNames = [];
    let selectedAlgorithmA = null;
    let selectedAlgorithmB = null;
    let isComparing = false;
    let currentCompareController = null;
    let progressAnimationId = null;
    let progressBarLoopCount = 0; // Zähler für die Loops der Progress Bar

    // UI-Referenzen (wie zuvor)
    const searchInputA = document.getElementById('searchInputA');
    const searchResultsA = document.getElementById('searchResultsA');
    const searchInputB = document.getElementById('searchInputB');
    const searchResultsB = document.getElementById('searchResultsB');
    const progressBar = document.getElementById('progressBar');
    const status = document.getElementById('status');
    const compareBtn = document.getElementById('compareBtn');
    const table = document.getElementById('resultTable');
    const tbody = table.querySelector('tbody');
    const frameA = document.getElementById('frameA');
    const frameB = document.getElementById('frameB');
    const elementCountInput = document.getElementById('elementCount');
    const speedInput = document.getElementById('vizSpeed');
    const datasetSelect = document.getElementById('datasetSelect');

    // --- Funktionen loadAlgorithms, updateSearchResults, selectAlgorithm, loadDatasets (wie zuvor) ---
    async function loadAlgorithms() { /* ... unverändert ... */
        try { const res = await fetch('/api/compare/algorithms'); if (!res.ok) throw new Error(`${res.status}`); const algos = await res.json(); algorithmDetails = {}; allAlgorithmNames = algos.map(algo => algo.name).sort(); algos.forEach(algo => algorithmDetails[algo.name] = algo); if (allAlgorithmNames.length >= 1) selectedAlgorithmA = allAlgorithmNames[0]; if (allAlgorithmNames.length >= 2) selectedAlgorithmB = allAlgorithmNames[1]; else if (allAlgorithmNames.length === 1) selectedAlgorithmB = allAlgorithmNames[0]; searchInputA.value = ''; searchInputB.value = ''; } catch (err) { console.error('Fehler Algorithmen:', err); allAlgorithmNames = []; }
    }
    function updateSearchResults(slot) { /* ... unverändert ... */
        const inputElement = (slot === 'A') ? searchInputA : searchInputB; const resultsContainer = (slot === 'A') ? searchResultsA : searchResultsB; const searchTerm = inputElement.value; resultsContainer.innerHTML = ''; let filteredList = []; const searchTermLower = searchTerm.trim().toLowerCase(); if (searchTermLower === '') { filteredList = [...allAlgorithmNames]; } else { const startsWithList = allAlgorithmNames.filter(name => name.toLowerCase().startsWith(searchTermLower)); const containsList = allAlgorithmNames.filter(name => !name.toLowerCase().startsWith(searchTermLower) && name.toLowerCase().includes(searchTermLower)); filteredList = startsWithList.concat(containsList); } if (filteredList.length > 0) { filteredList.forEach(algoName => { const itemDiv = document.createElement('div'); itemDiv.classList.add('search-result-item'); itemDiv.onclick = () => selectAlgorithm(algoName, slot); const nameSpan = document.createElement('span'); if (searchTermLower !== '') { const escapedSearchTerm = searchTermLower.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); const regex = new RegExp(`(${escapedSearchTerm})`, 'gi'); nameSpan.innerHTML = algoName.replace(regex, '<b>$1</b>'); } else { nameSpan.textContent = algoName; } itemDiv.appendChild(nameSpan); resultsContainer.appendChild(itemDiv); }); resultsContainer.style.display = 'block'; } else { const noResultDiv = document.createElement('div'); noResultDiv.classList.add('search-result-item'); noResultDiv.style.fontStyle = 'italic'; noResultDiv.textContent = "Keine Übereinstimmung"; resultsContainer.appendChild(noResultDiv); resultsContainer.style.display = 'block'; }
    }
    function selectAlgorithm(algoName, slot) { /* ... unverändert ... */
        if (slot === 'A') { selectedAlgorithmA = algoName; searchInputA.value = algoName; searchResultsA.style.display = 'none'; } else if (slot === 'B') { selectedAlgorithmB = algoName; searchInputB.value = algoName; searchResultsB.style.display = 'none'; }
    }
    async function loadDatasets() { /* ... unverändert ... */
        let elementCount = parseInt(elementCountInput.value, 10); const minCount = 5, maxCount = 1000000; if (isNaN(elementCount) || elementCount < minCount) elementCount = minCount; else if (elementCount > maxCount) elementCount = maxCount; elementCountInput.value = elementCount; try { const res = await fetch(`/api/compare/datasets?count=${elementCount}`); if (!res.ok) throw new Error(`HTTP ${res.status}`); const data = await res.json(); datasets = data || {}; const previousValue = datasetSelect.value; datasetSelect.innerHTML = ''; let foundPrevious = false; for (const key of Object.keys(datasets)) { const opt = document.createElement('option'); opt.value = key; opt.textContent = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()); datasetSelect.appendChild(opt); if (key === previousValue) { opt.selected = true; foundPrevious = true; } } if (!foundPrevious && datasetSelect.options.length > 0) datasetSelect.selectedIndex = 0; else if (datasetSelect.options.length === 0) datasetSelect.innerHTML = '<option value="">Keine Datensätze</option>'; } catch (err) { console.error("Fehler Datensätze:", err); datasets = {}; datasetSelect.innerHTML = '<option value="">Fehler</option>'; }
    }

    /**
     * Setzt die Benutzeroberfläche zurück (nach Anzeige oder Abbruch).
     */
    function resetUI() {
        isComparing = false;
        compareBtn.textContent = 'Vergleichen';
        compareBtn.disabled = false;
        compareBtn.classList.remove('cancel-btn');

        status.style.display = 'none';
        progressBar.style.display = 'none'; // ProgressBar sicher ausblenden
        progressBar.value = 0;

        if (progressAnimationId) {
            cancelAnimationFrame(progressAnimationId);
            progressAnimationId = null;
        }
        progressBarLoopCount = 0; // Wichtig: Loop-Zähler zurücksetzen
        currentCompareController = null;

        // Eingabefelder aktivieren
        searchInputA.disabled = false;
        searchInputB.disabled = false;
        datasetSelect.disabled = false;
        elementCountInput.disabled = false;
        speedInput.disabled = false;
    }

    /**
     * Bricht einen laufenden Vergleich ab und setzt UI zurück.
     */
    function cancelCompare() {
        if (currentCompareController) {
            currentCompareController.abort();
            console.log("Vergleichs-Anfrage abgebrochen.");
        }
        isComparing = false; // Zustand sofort ändern
        if (progressAnimationId) { // Animation sofort stoppen
            cancelAnimationFrame(progressAnimationId);
            progressAnimationId = null;
        }
        compareBtn.textContent = 'Wird abgebrochen...';
        compareBtn.disabled = true;

        setTimeout(() => {
            resetUI(); // Reset aufrufen (blendet auch Progressbar aus etc.)
            // Tabelle/Iframes sicher ausblenden
            table.style.display = 'none';
            frameA.style.display = 'none';
            frameB.style.display = 'none';
            frameA.src = 'about:blank'; // Leeren
            frameB.src = 'about:blank'; // Leeren
            status.textContent = "Vergleich abgebrochen.";
            status.style.display = 'inline';
            setTimeout(() => { if (!isComparing) status.style.display = 'none'; }, 1500);
        }, 300);
    }


    /**
     * Animiert den Fortschrittsbalken mit exponentieller Verlangsamung und Verlangsamung pro Loop.
     */
    function animateProgressBar() {
        const baseIncrementLinear = 0.5; // Grundgeschwindigkeit für 0-90%
        const baseIncrementExpoMin = 0.01; // Mindestgeschwindigkeit für 90-99%
        const expoFactor = 0.02; // Faktor für exponentielle Verlangsamung

        progressBarLoopCount = 0; // Zähler bei Start zurücksetzen

        function step() {
            if (!isComparing) { // Stoppe sofort, wenn nicht mehr verglichen wird
                progressAnimationId = null;
                return;
            }

            let progress = progressBar.value;
            // Aktuelle Geschwindigkeit basierend auf Loop-Anzahl berechnen (halbiert pro Loop)
            // Math.pow(basis, exponent)
            const speedModifier = Math.pow(0.5, progressBarLoopCount); // 0.5^0=1, 0.5^1=0.5, 0.5^2=0.25 etc.
            const currentIncrementLinear = baseIncrementLinear * speedModifier;
            const currentIncrementExpoMin = baseIncrementExpoMin * speedModifier;

            if (progress < 90) {
                progress += Math.max(0.01, currentIncrementLinear); // Mindestbewegung sicherstellen
            } else if (progress < 99) {
                const remaining = 99 - progress;
                // Increment wird kleiner, je näher an 99, und langsamer pro Loop
                const increment = Math.max(currentIncrementExpoMin, remaining * expoFactor * speedModifier);
                progress += increment;
            } else {
                // Bei 99% angekommen -> Neustart bei 0 und Loop zählen
                progress = 0;
                progressBarLoopCount++; // Erhöhe Zähler für nächsten, langsameren Durchlauf
                console.log(`Progress bar loop ${progressBarLoopCount}, speed modifier: ${Math.pow(0.5, progressBarLoopCount)}`); // Log zur Info
            }

            progressBar.value = Math.min(progress, 99); // Kappe bei 99

            progressAnimationId = requestAnimationFrame(step); // Nächsten Frame anfordern
        }
        // Starte die Animation nur, wenn sie nicht schon läuft
        if (!progressAnimationId) {
            progressAnimationId = requestAnimationFrame(step);
        }
    }

    /**
     * Zeigt die Ergebnisse an (ohne CSS-Klassen für Transition).
     */
    function showResultsAndVisualizations(data, datasetKey, vizSpeed, elementCount) {
        if (!tbody) { console.error("Tabellen-Body (tbody) nicht gefunden!"); return; }
        tbody.innerHTML = '';

        data.forEach(row => { /* ... Tabellenzeilen erstellen wie zuvor ... */
            const tr = document.createElement('tr');
            const unsortedPreview = (row.unsorted || []).slice(0, 50).join(', ') + ((row.unsorted?.length || 0) > 50 ? '...' : '');
            const sortedPreview = (row.sorted || []).slice(0, 50).join(', ') + ((row.sorted?.length || 0) > 50 ? '...' : '');
            tr.innerHTML = `<td>${row.algorithm ?? '-'}</td><td>${row.durationMillis?.toLocaleString() ?? '-'}</td><td>${row.steps?.toLocaleString() ?? '-'}</td><td>${unsortedPreview || '-'}</td><td>${sortedPreview || '-'}</td><td>${row.worstCase ?? '-'}</td><td>${row.averageCase ?? '-'}</td><td>${row.bestCase ?? '-'}</td>`;
            tbody.appendChild(tr);
        });

        // Tabelle und Iframes direkt sichtbar machen via display
        table.style.display = 'table'; // Korrekter Display-Wert für Tabellen
        frameA.style.display = 'block';
        frameB.style.display = 'block';

        // Visualisierungen laden
        const vizUrlParams = `&dataset=${encodeURIComponent(datasetKey)}&speed=${vizSpeed}&count=${elementCount}`;
        // Wichtig: Kurze Verzögerung *vor* dem Setzen der src, damit das display:block erst wirkt
        setTimeout(() => {
            frameA.src = `/visualizer.html?algo=${encodeURIComponent(selectedAlgorithmA)}${vizUrlParams}`;
            frameB.src = `/visualizer.html?algo=${encodeURIComponent(selectedAlgorithmB)}${vizUrlParams}`;
        }, 50); // 50ms sollten reichen

        status.textContent = "Vergleich abgeschlossen."; // Finale Statusmeldung
    }


    /**
     * Startet den Vergleichsprozess.
     */
    async function startCompare() {
        // --- Gültigkeit der Auswahl prüfen ---
        if (!selectedAlgorithmA || !selectedAlgorithmB || !allAlgorithmNames.includes(searchInputA.value) || !allAlgorithmNames.includes(searchInputB.value)) { /*...*/ alert("..."); return; }
        selectedAlgorithmA = searchInputA.value; selectedAlgorithmB = searchInputB.value;

        // Alte Ergebnisse/Visualisierungen ausblenden via display
        table.style.display = 'none';
        frameA.style.display = 'none';
        frameB.style.display = 'none';
        frameA.src = 'about:blank'; frameB.src = 'about:blank';
        if (tbody) tbody.innerHTML = '';

        // Parameter holen und validieren (wie zuvor)
        const elementCount = parseInt(elementCountInput.value, 10);
        let vizSpeed = parseInt(speedInput.value, 10);
        const datasetKey = datasetSelect.value;
        // ...(Validierungslogik wie zuvor)...
        const minCount = 5, maxCount = 1000000, minSpeed = 0, maxSpeed = 1000; if (isNaN(elementCount) || elementCount < minCount || elementCount > maxCount) { await loadDatasets(); startCompare(); return; } if (isNaN(vizSpeed) || vizSpeed < minSpeed || vizSpeed > maxSpeed) { speedInput.value = vizSpeed = isNaN(vizSpeed) || vizSpeed < minSpeed ? minSpeed : maxSpeed; } const inputData = datasets[datasetKey]; if (!inputData) { await loadDatasets(); if (!datasets[datasetKey]) { resetUI(); return; } startCompare(); return; }


        // --- Warnung (wie zuvor) ---
        // ...(Warnungslogik wie zuvor)...
        const detailsA = algorithmDetails[selectedAlgorithmA]; const detailsB = algorithmDetails[selectedAlgorithmB]; let showWarning = false; /* ... Logik ... */ if (showWarning) { const proceed = confirm(`WARNUNG:\n${reason}\n\nStart?`); if (!proceed) return; }

        // --- Vergleich starten ---
        isComparing = true;
        currentCompareController = new AbortController();

        // UI für Ladezustand
        status.style.display = 'inline'; status.textContent = "Sortiere Daten...";
        compareBtn.textContent = 'Abbruch'; compareBtn.classList.add('cancel-btn');
        progressBar.style.display = 'block'; // Progressbar sichtbar machen
        progressBar.value = 0; // Start bei 0

        // Eingabefelder deaktivieren
        searchInputA.disabled = true; searchInputB.disabled = true; datasetSelect.disabled = true; elementCountInput.disabled = true; speedInput.disabled = true;

        // Starte die Progress Bar Animation
        animateProgressBar();

        let fetchedData = null; // Variable für die Ergebnisse

        try {
            // Request-Payload und Fetch (wie zuvor)
            const payload = { algorithms: [selectedAlgorithmA, selectedAlgorithmB], input: inputData };
            const res = await fetch('/api/compare', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal: currentCompareController.signal });

            // ***** Fetch ist fertig *****
            isComparing = false; // Signalisiert der Animation, dass Fetch fertig ist
            if (progressAnimationId) cancelAnimationFrame(progressAnimationId); // Stoppe die Animation
            progressAnimationId = null; // ID zurücksetzen
            progressBar.value = 100; // Setze Balken auf 100%

            // Fehlerbehandlung für Fetch
            if (!res.ok) { let e = `Fetch Error: ${res.status}`; try { const d = await res.json(); e += `\n${d.message||''}`; } catch(_) {} throw new Error(e); }

            fetchedData = await res.json();
            status.textContent = "Vergleich abgeschlossen. Zeige Ergebnisse...";


        } catch (err) { // Fehler oder Abbruch
            isComparing = false; if (progressAnimationId) cancelAnimationFrame(progressAnimationId); progressAnimationId = null;
            if (err.name === 'AbortError') { console.log("Fetch abgebrochen."); /* resetUI durch cancelCompare */ }
            else { console.error("Fehler:", err); alert("Fehler: " + (err.message || "Unbekannt")); status.textContent = "Fehler!"; progressBar.value = 0; setTimeout(resetUI, 1500); }
            return; // Wichtig: Beende bei Fehler/Abbruch
        }

        // --- Erfolgreicher Abschluss ---
        // Kurze Verzögerung (z.B. 300ms), um 100% anzuzeigen, dann ausblenden und Ergebnisse zeigen
        setTimeout(() => {
            // Nur fortfahren, wenn nicht zwischenzeitlich abgebrochen wurde
            if (!currentCompareController || !currentCompareController.signal.aborted) {
                progressBar.style.display = 'none'; // Progressbar ausblenden
                if (fetchedData) {
                    // Ergebnisse und Visualisierungen anzeigen (JETZT)
                    showResultsAndVisualizations(fetchedData, datasetKey, vizSpeed, elementCount);
                }
                resetUI(); // UI-Eingaben etc. zurücksetzen
            } else {
                console.log("Anzeige übersprungen, da Abbruch nach Fetch erfolgte.");
                // resetUI wurde bereits von cancelCompare aufgerufen
            }
        }, 300);

    }

    // --- Event Listener (wie zuvor) ---
    compareBtn.addEventListener('click', () => { if (isComparing) cancelCompare(); else startCompare(); });
    elementCountInput.addEventListener('change', loadDatasets);
    searchInputA.addEventListener('input', () => updateSearchResults('A')); searchInputA.addEventListener('focus', () => updateSearchResults('A')); searchInputA.addEventListener('blur', () => { setTimeout(() => { if (!searchResultsA.contains(document.activeElement)) { searchResultsA.style.display = 'none'; if (!allAlgorithmNames.includes(searchInputA.value)) searchInputA.value = selectedAlgorithmA ?? ''; } }, 150); });
    searchInputB.addEventListener('input', () => updateSearchResults('B')); searchInputB.addEventListener('focus', () => updateSearchResults('B')); searchInputB.addEventListener('blur', () => { setTimeout(() => { if (!searchResultsB.contains(document.activeElement)) { searchResultsB.style.display = 'none'; if (!allAlgorithmNames.includes(searchInputB.value)) searchInputB.value = selectedAlgorithmB ?? ''; } }, 150); });

    // Initiales Laden
    async function initializeApp() { await loadAlgorithms(); await loadDatasets(); }
    initializeApp();

</script>
</body>
</html>